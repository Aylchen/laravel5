1 ）安装laravel时
	
	a) composer global require “laravel/installer=~1.1”
	b) 将~/.composer/vendor/bin路径添加到环境变量中:
		
		vim /etc/profile 
		在最后添加:export PATH=”~/.composer/vendor/bin:$PATH”
		保存；
		执行source /etc/profile，不报错即成功
 
		通过echo $PATH可查看

	通过：
		composer create-project laravel/laravel –prefer-dist

访问方法：
1）使用php 内置服务 php -S localhost:port -t /path/
2） 使用artisan ： php artisan serve
3）搭建虚拟主机，见desktop另一篇文档：ubuntu配置虚拟主机;

Laravel:

请求的生命周期:
1) 创建应用实例$app;
2) 通过kernel(http/console)处理request,并向客户端返回response;
	在处理request前,
	a) 加载bootstrapers数组中定义的类,这些类用来进行错误处理/日志记录/环境侦测等;
	b) 加载中间件$middleware数组中的类,用来验证CSRF/session cookie处理等
		a) and b) : bootstrap/app.php
	c) handle Reuest, and send Response;

Service Provider : 服务提供者

config/app.php $providers

console : php artisan make:provider <ServiceProviderName>

1) extends Illuminate\Support\ServiceProvider;
2) 定义register方法，并只绑定服务到服务容器中；
3) 在所有的Service Provider注册后，boot方法被调用；在boot方法中注册事件监听/路由等；
4） 注册服务提供者:config/app.php
	在providers数组中添加;
5) 延缓注册:
	a) protected $defer = true;
	b) 定义provides方法: 返回与服务容器绑定的服务提供者服务
	   returns the service container bindings that the provider register
		public function provides()
		{
			return ['Riak\Contracts\Connection'];
		}

Service Container : 服务容器

服务容器与服务提供者绑定;(register)
	
1) Service Provider中,通过 $this->app来访问容器;
2) 使用bind方法注册一个绑定,参数为类/接口名，返回类的实例(instance);
	$this-app->bind('<...>',function($app){ return new <...>( $app[''] ); })
3)  注册一个单例 singleton
	$this->app->singleton('FooBar', function($app) {
		return new FooBar($app['...']);   //同上 bind方法
	});

4） 绑定已存在的实例	 instance
	$obj = new FooBar(new …); 
	$this->app->instance('FooBar',$obj);

5) Binding Interfaces To Implementations
	$this->app->bind('<Interfaces>','<Implementation>');

6) Contextual Binding
	不同的类用的同样的接口实现，但根据需要来注册服务
	$this->app -> when('Utilization Command') //比如当我们接收到订单时
		     -> needs('Interface')	
		     -> give（'Implementation1');

解析：make

1) $this->app->make('<class/interface>');
2) $this->app['<class/interface>']; //ArrayAccess

容器事件: Container Events  resolving

Each time the service container resolving an object will fire an event;

$this->app->resolving (function ($object, $app) {
	//called when container resolves object of any type
});

$this->app->resolving (function (FooBar $object, $app) {
	//called when container resolves object of “FooBar”
});


Contracts：低耦合/简单性

定义了框架核心服务的接口(interfaces)
"type-hint" the interface in the constructor of the class being resolved.


Facades：


facade ： 提供从容器访问对象的一个类
extends Illuminate\Suppoer\Facades\Facade
只需要实现getFacadeAccessor方法(用来返回服务容器绑定的名称)














路由

1) 基础路由  get/post/put/delete
	Route::get('<routePath>',function () { return … });
	

2) 为多种请求注册路由  match
	Route::match(['get','post'],'<routePath>', function () { return ... });

3） 响应所有请求  any
	Route::any('<routePath>',function () { return … });
	
为路由生成url : $url = url('<routePath>');//url is a helper-method name
	

路由参数

1/ Route::get('<routePath>/{id}', function ($id) { return ...($id); });
n/ Route::get('<routePath>/{id1}/<routePath2>/{id2}...', function ($id1,$id2) { return ...($id1)...($id2); });

可选路由参数
	Route::get('user/{name?}', function($name = null) { return $name; });

带默认值
	Route::get('user/{name?}', function($name = '...') { return $name; });

使用正则表达式
Route::get('user/{name}',function ( $name ) { … })->where('name','[A-Za-z]');
Route::get('user/{name}/{id}',function ( $name, $id ) { … })
	->where(['name' => '[A-Za-z]', 'id' => '[0-9]']);

全局约束
在RouterServiceProvider中的boot方法中添加：
	$router->pattern('id','[0-9]');
此时会作用在下述路由：
	Route::get('user/{id},function($id) { … });



路由命名
	Route::get('user/profile',['as' => 'profile', function() { }]);
	Route::get('user/profile','UserController@showProfile')->name('profile');

为控制器动作指定名称
	Route::get('user/profile',
		['as' => 'profile', 'uses' => 'UserProfileController@showProfile']);

为已命名的路由生成url :
	不带parameters: $url = route('profile');
	带parameters:   (作为route的第二个参数
			Route::get('user/{id}/profile', 
				['as'=>'profile',function ($id){ … }]);

			$url = route('profile',['id' => 1 ]);

路由组

	共享属性以数组形式作为Route::group的第一参数传入
	Route::group([], function () {});
子域名路由：?????????
Route::group(［'domain' => '{account}....com'］,function () {
	Route::get('user/{id}', function ($account, $id) {
		return “account is:”.$account.”****And id is:”.$id;
	}
}


路由模型绑定
Route::get


MiddleWare

$ php artisan make:middleware middleWareName
注册中间件
1） 将中间件的类添加至app/Http/Kernel.php的$middleWare 属性中
2） 指派中间件给路由
	Route::get('...',['middleware' => ['first','second'],function (){ 

	}]);
OR
	Route::get('...',function (){ 

	})->middleware(['first','second']);


Route::resource

Route::resource('photo', 'PhotoController',
                ['only' => ['index', 'show']])
Route::resource('photo', 'PhotoController',
                ['except' => ['create', 'store', 'update', 'destroy']]);



Controller：(隐式控制器）

Route::controller（URI:'users'，ControllerName:'UserController');
然后在控制器中加入方法（以http请求方式开头)
getIndex()/ getShow($id):users/show/{id} / postrPofile : users/profile(post)

指定路由名称(第三个参数)
Route::controller（URI:'users'，ControllerName:'UserController', ['getShow' => 'user.show' ]);

可在__construct()中指定中间件，作用在当前控制器


Views 视图

view('<viewName>')->with('key',$val);
view('<viewName>', $array());//{{ $key }} 获取$array($key)的值
view('<viewName>', compact('variableName');//{{ $variableName }}

share 方法共享数据给所有视图
在AppServiceProvider的boot方法中使用:
	View::share('key','value');

查看视图是否存在
if(view() -> exists('<viewName>') { }

视图组件：View Composer
	在视图被渲染前，会调用的闭包或者类方法

在service provider中注册视图组件，



Blade Templates:

resources/views  with .blade.php file extension

1)模板继承
	a)定义一个layout（用于子模板继承） :父模板（自定义的名字）
		$yield('')
	b)继承模板
		@extends('<layoutName>')

	模板渲染顺序：
		a) 从controller指定过来的view，
			跳过带@符号的，先从头到位渲染完
		b) 从第一个@extends开始，从上到下开始渲染，有@yield就去找section


	{{ }} 防止XSS 攻击

{{ $name or 'Default' }} //类似三元运算符功能

@if @elseif @else @endif
 
@foreach @endforeach

@for @endfor 

@forelse @empty @endforelse

@while @endwhile

@include('view.name',['key' => 'value'])


{{-- comment --}} 


引入服务：@inject('variableName','Service wished to resolve')
























